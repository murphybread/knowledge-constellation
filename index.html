<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js 백지 시작</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        z-index: 60;
        display: block;
        color: white;
        font-size: 20px;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="info">This is a text overlay using DOM + CSS</div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      // scene , camera, renderer 파트
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        1,
        50
      );
      camera.position.set(0, 0, 30);
      camera.lookAt(0, 0, 0);
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 도현 파트
      const FORCE = 5;
      const circleGeometry = new THREE.CircleGeometry(1, 16);
      const circleMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700 });
      const star = new THREE.Mesh(circleGeometry, circleMaterial);
      star.velocity = new THREE.Vector3(
        (Math.random() - 0.5) * FORCE,
        (Math.random() - 0.5) * FORCE,
        (Math.random() - 0.5) * FORCE
      );
      scene.add(star);

      function checkBoundary(ndcPosition, object) {
        if (ndcPosition.x > 1 || ndcPosition.x < -1) {
          object.velocity.x = -object.velocity.x;
        }
        if (ndcPosition.y > 1 || ndcPosition.y < -1) {
          object.velocity.y = -object.velocity.y;
        }
        if (ndcPosition.z > 0.9 || ndcPosition.z < -0.9) {
          object.velocity.z = -object.velocity.z;
        }
      }

      function animate() {
        requestAnimationFrame(animate);
        star.position.add(star.velocity);
        const worldPos = star.position.clone().project(camera);
        checkBoundary(worldPos, star);

        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>
